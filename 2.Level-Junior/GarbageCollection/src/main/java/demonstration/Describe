Создать объект User c полями и перекрытым методом finalize

Создать несколько объектов User и руками рассчитать сколько он будет занимать памяти.
    Пустой объект без полей будет занимать для х32 8 байт х64 16 байт это длина заголовка.
    При
    В загоовок входит:
        Mark word
            hascode - каждый объект имеет метод hascode.
                По умолчанию вызов метода Object.hashcode() вернет адрес
                объекта в памяти.
            Garbage Collection information - каждый объект содержит
                инфромацию необходимую для управления памати сборщиком мусора
                (Возможность помечать объекта чтобы различать "живых").
            Lock - каждый объект содержит информацию о состоянии блокировки.
                Это может быть указатель на объект блокировки или премое
                представление блокировки.
        Type Information Block pointer - содержит информацию о типе объекта
            (таблица виртуальных методов, указатель на объект, указатели на
            некоторые дополнительные структуры).
        Array Length - если объект - массив, то заголовок расширяется 4 байтами
            для хранения длинны массива.
        Смещение/Выравнивание - это несколько не используемых байт, которые
            размещаются после самого объекта. Сделано для того чтобы адрес
            в памяти был кратен машиному слову это необходимо для(ускорения
            чтения из памяти, уменьшения количиства бит для указателя на объект,
            для уменьшения фрагментации памяти).

    Размер любого объекта в Java кратен 8 байтам.

    Объект будем занимать заголовок + все на что он ссылается.

Нужно найти информацию. Сколько памяти занимает пустой объект без полей.
    UserClass.PNG - без полей
    UserClassWithStringFild.PNG - с одним полем String

Добиться состояния, когда виртуальная машины вызывает сборщик мусора самостоятельно.
За счет ключей xmx.
    При запуске иетода main происходит вызов GC.Использовались ключи
    -Xmx10m максимальный размер HEAP 10МБ
    -XX:NewRatio=1 Соотношение EDEN к HEAP одинаковы. Размер максимального
        значения HEAP, EDEN одинаковы.
Объяснить поведение программы в текстовом файле.
    В методе майн создается один объект user strongRef который не будет
    уничтожен так как обеъект имеет пряму действующую ссылку, и во вложеном
    цикле создаются объекты этого же класса User, но доступных ссылок на эти
    экземмпляры нет. После создания все объекты попадают в область EDEN, когда
    происходит маркировка GC объектов на удаление, объекты которые имеют
    действующих ссылки будут перемещены в Survivor(0,1) для дальнейшего
    хранения, а остальные удалены, со временем Survivor области заполняются
    и тогда "выжившие" переносятся в область OldGen для хранения объектов с долгим
    жизненым циклом.
        HEAP Делится на области которые можно настраивать указывая их размер.
            "молодые объекты" - EDEN + S1 + S0
            OldGen - объекты с длительным жизненым циклом.
        В зависимости от реализации GC отличается и алгоритмы работы с этими областями.

